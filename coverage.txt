    1|       |//
    2|       |//  main.cpp
    3|       |//  Assignment4
    4|       |//
    5|       |//  Created by Ben Trueman on 1/15/19.
    6|       |//  Copyright Â© 2019 Ben Trueman. All rights reserved.
    7|       |//
    8|       |
    9|       |#include <iostream>
   10|       |#include <regex>
   11|       |#include <set>
   12|       |//#include "functions.hpp"
   13|       |#include <vector>
   14|       |#include <sstream>
   15|       |#include <cmath>
   16|       |using namespace std;
   17|    600|#define pdd pair<double, double>
   18|       |
   19|       |/* Classifies Quadrilaterals according to https://www.varsitytutors.com/hotmath/hotmath_help/topics/quadrilaterals.
   20|       | In particular, see the Venn diagram at the bottom of the page. Always classify a quadrilateral as precisely as possible. In other words, a square is also a rectangle, but since "square" is the more precise classification it is what you should print.
   21|       | Your input arrives on the standard input stream and is a list of quadrilaterals, one per line. Each line describes 3 vertices, which should be treated as arriving in clockwise order, starting from an implied first vertex at 0,0.
   22|       | Input lines are of the form:
   23|       | x1 y1 x2 y2 x3 y3
   24|       | All input values are integers in the range 0..100 (inclusive).
   25|       |
   26|       | If your program gets an invalid line of input it must print one of the strings below and then terminate. It should print:
   27|       | 
   28|       | "error 1" -- if the line contains the wrong number of points, contains invalid characters, has coordinates out of the range 0..100, or otherwise fails to describe three points (six integer values)
   29|       | "error 2" -- if any two points coincide
   30|       | "error 3" -- if any two line segments representing sides cross each other
   31|       | "error 4" -- if any three points are colinear1
   32|       |*/
   33|       |
   34|       |//must contain 0-9 or space only. Returns true if an errof is found http://www.cplusplus.com/reference/string/string/find_first_not_of/
   35|    100|bool error1(std::string s){
   36|    100|    size_t found = s.find_first_not_of("0123456789 ");
   37|    100|    return (found != std::string::npos);
   38|    100|}
   39|       |
   40|       |//must contain 6 ints in range 0 to 100
   41|    100|bool error1(std::vector<int> vect){
   42|    100|    if(vect.size() != 6) return true;
   43|    100|    
   44|    600|    for(int i: vect){
   45|    600|        if(i < 0 || i > 100) return true;
   46|    100|    }
   47|    100|    return false;
   48|    100|}
   49|       |
   50|     68|void exitError(std::string error){
   51|     68|    std::cout << error << std::endl;
   52|     68|        exit (EXIT_FAILURE);
   53|     68|}
   54|       |
   55|       |//"error 2" -- if any two points coincide http://www.cplusplus.com/reference/vector/vector/operators/
   56|    100|bool error2(std::vector<int> vect){
   57|    100|    std::vector<int> A = {0,0};
   58|    100|    std::vector<int> B = {vect[0],vect[1]};
   59|    100|    std::vector<int> C = {vect[2],vect[3]};
   60|    100|    std::vector<int> D = {vect[4],vect[5]};
   61|    100|    
   62|    100|    if(A == B || A == C || A == D || B == C || B == D || C == D){
   63|      0|        return true;
   64|      0|    }
   65|    100|    return false;
   66|    100|}
   67|       |
   68|       |//"error 3" -- if any three points are colinear
   69|       |//A1 and A2 are 0 and 1
   70|       |//B1 and B2 are 2 and 3
   71|       |//C1 and C2 are 4 and 5
   72|       |//D1 and D2 are 6 and 7
   73|    200|pdd lineLineIntersection (pdd A, pdd B, pdd C, pdd D) {
   74|    200|    // Line AB represented as a1x + b1y = c1
   75|    200|    double a1 = B.second - A.second;
   76|    200|    double b1 = A.first - B.first;
   77|    200|    double c1 = a1*(A.first) + b1*(A.second);
   78|    200|    
   79|    200|    // Line CD represented as a2x + b2y = c2
   80|    200|    double a2 = D.second - C.second;
   81|    200|    double b2 = C.first - D.first;
   82|    200|    double c2 = a2*(C.first)+ b2*(C.second);
   83|    200|    
   84|    200|    double determinant = a1*b2 - a2*b1;
   85|    200|    
   86|    200|    if (determinant == 0)
   87|      0|    {
   88|      0|        // The lines are parallel. This is simplified
   89|      0|        // by returning a pair of FLT_MAX
   90|      0|        return make_pair((double)__FLT_MAX__, (double)__FLT_MAX__);
   91|      0|    }
   92|    200|    else
   93|    200|    {
   94|    200|        double x = (b2*c1 - b1*c2)/determinant;
   95|    200|        double y = (a1*c2 - a2*c1)/determinant;
   96|    200|        return make_pair(x, y);
   97|    200|    }
   98|    200|}
   99|       |
  100|    100|bool error3 (const vector<int> &coords){
  101|    100|    pdd A = make_pair(0, 0);
  102|    100|    pdd B = make_pair(coords[0], coords[1]);
  103|    100|    pdd C = make_pair(coords[2], coords[3]);
  104|    100|    pdd D = make_pair(coords[4], coords[5]);
  105|    100|    
  106|    100|    //line AB BC CD DA
  107|    100|    pdd intersection1 = lineLineIntersection(A, B, C, D);
  108|    100|    pdd intersection2 = lineLineIntersection(A, D, C, B);
  109|    100|    
  110|    100|    int xMax = 0;
  111|    100|    int yMax = 0;
  112|    100|    
  113|    400|    for(int i = 0 ; i<coords.size(); i+=2){
  114|    300|        if(coords[i]>xMax){
  115|    184|            xMax=coords[i];
  116|    184|        }
  117|    300|    }
  118|    100|    
  119|    400|    for(int i=1; i<coords.size(); i+=2){
  120|    300|        if(coords[i]>yMax){
  121|    175|            yMax=coords[i];
  122|    175|        }
  123|    300|    }
  124|    100|    if (intersection1.first<xMax && intersection1.second<yMax && intersection1.first>0 && intersection1.second>0){
  125|     65|        //if intersection y > AB max y
  126|     65|        if(intersection1.second > coords[1]){
  127|     13|            return false;
  128|     13|        }
  129|     52|        return true;
  130|     52|    }
  131|     35|    if(intersection2.first<xMax && intersection2.second<yMax && intersection2.second>0 && intersection2.second>0){
  132|     16|        return true;
  133|     16|    }
  134|     19|    return false;
  135|     19|}
  136|       |
  137|       |//adapted from https://www.geeksforgeeks.org/program-check-three-points-collinear/
  138|    128|bool collinear(int x1, int y1, int x2,int y2, int x3, int y3) {
  139|    128|    int a = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2);
  140|    128|    return (a == 0);
  141|    128|}
  142|       |
  143|       |//"error 4" -- if any three points are colinear
  144|     32|bool error4(std::vector<int> vect){
  145|     32|    if(collinear(0, 0, vect[0], vect[1], vect[2], vect[3])) return true;//A B C
  146|     32|    if(collinear(0, 0, vect[0], vect[1], vect[4], vect[5])) return true;//A B D
  147|     32|    if(collinear(0, 0, vect[2], vect[3], vect[4], vect[5])) return true;//A C D
  148|     32|    if(collinear(vect[0], vect[1], vect[2], vect[3], vect[4], vect[5])) return true;//B C D
  149|     32|    return false;
  150|     32|}
  151|       |
  152|    100|std::vector<int> parseToVector(std::string &string){
  153|    100|    std::stringstream iss(string);
  154|    100|    std::string number;
  155|    100|    std::vector<int> parsedInput;
  156|    700|    while (iss >> number){
  157|    600|        parsedInput.push_back(std::stoi(number));
  158|    600|    }
  159|    100|    return parsedInput;
  160|    100|}
  161|       |
  162|       |//slope = (Y2 - Y1)/(X2 - X1)
  163|    128|double slope(const int &xA, const int &yA, const int &xB, const int &yB){
  164|    128|    if(yB - yA == 0 || xB - xA == 0) return 0; //return zero for horizontal or vertical lines
  165|    126|    double slopeAB = (double)(yB - yA)/(xB - xA);
  166|    126|    return slopeAB;
  167|    126|}
  168|       |
  169|       |//distance between two vertices
  170|    128|double distance(const int &x1, const int &y1, const int &x2, const int &y2){
  171|    128|    double distance = 0;
  172|    128|    distance = sqrt(pow((x2 - x1),2) + pow((y2 - y1),2));
  173|    128|    return distance;
  174|    128|}
  175|       |
  176|    128|bool areParallel(const double &slopeA, const double &slopeB){
  177|    128|    return (std::abs((slopeA - slopeB)) < 0.001);
  178|    128|}
  179|       |
  180|       |//are both pairs of opposite sides parallel? .
  181|     32|bool isParallelogram(const double &slopeAB, const double &slopeBC, const double &slopeCD, const double &slopeDA){
  182|     32|    return areParallel(slopeAB, slopeCD) && areParallel(slopeDA, slopeBC);
  183|     32|}
  184|       |
  185|       |// Rectangle: four right angles (slopes of all 4 lines must be zero since one vertice is locked at 0,0)
  186|      0|bool isRectangle(const double &slopeAB, const double &slopeBC, const double &slopeCD, const double &slopeDA){
  187|      0|    return (slopeAB == 0 && slopeBC == 0 && slopeCD == 0 && slopeDA == 0);
  188|      0|}
  189|       |
  190|       |// Rhombus: four sides of the same length
  191|      0|bool isRhombus(const double &distanceAB, const double &distanceBC, const double &distanceCD, const double &distanceDA){
  192|      0|    return (distanceAB - distanceBC + distanceCD - distanceDA == 0);
  193|      0|}
  194|       |
  195|       |// Trapezoid: only one pair of parallel sides
  196|     32|bool isTrapezoid(const double &slopeAB, const double &slopeBC, const double &slopeCD, const double &slopeDA){
  197|     32|    return ((areParallel(slopeAB,slopeCD) && !areParallel(slopeBC, slopeDA)) || (!areParallel(slopeAB,slopeCD) && areParallel(slopeBC, slopeDA)));
  198|     32|}
  199|       |
  200|       |// Kite: two pairs of adjacent congruent sides
  201|     32|bool isKite(const double &distanceAB, const double &distanceBC, const double &distanceCD, const double &distanceDA){
  202|     32|    int counter = 0;
  203|     32|    if(distanceAB == distanceBC || distanceAB == distanceDA) counter++;
  204|     32|    if(distanceCD == distanceDA || distanceCD == distanceBC) counter++;
  205|     32|    return counter == 2;
  206|     32|}
  207|       |
  208|     32|void printQuadrilateralType(const std::vector<int> &vect){
  209|     32|    if(vect.size() != 0) {
  210|     32|        double distanceAB = distance(0,0,vect[0],vect[1]);
  211|     32|        double distanceBC = distance(vect[0],vect[1],vect[2],vect[3]);
  212|     32|        double distanceCD = distance(vect[2],vect[3],vect[4],vect[5]);
  213|     32|        double distanceDA = distance(vect[4],vect[5],0,0);
  214|     32|        double slopeAB = slope(0,0,vect[0],vect[1]);
  215|     32|        double slopeBC = slope(vect[0],vect[1],vect[2],vect[3]);
  216|     32|        double slopeCD = slope(vect[2],vect[3],vect[4],vect[5]);
  217|     32|        double slopeDA = slope(0,0,vect[4],vect[5]);
  218|     32|        
  219|     32|        if(isParallelogram(slopeAB, slopeBC, slopeCD, slopeDA)){
  220|      0|            if(isRectangle(slopeAB, slopeBC, slopeCD, slopeDA) && isRhombus(distanceAB, distanceBC, distanceCD, distanceDA)){
  221|      0|                std::cout << "square" << std::endl;
  222|      0|            } else if (isRectangle(slopeAB, slopeBC, slopeCD, slopeDA)){
  223|      0|                std::cout << "rectangle" << std::endl;
  224|      0|            } else if (isRhombus(distanceAB, distanceBC, distanceCD, distanceDA)){
  225|      0|                std::cout << "rhombus" << std::endl;
  226|      0|            } else std::cout << "parallelogram" << std::endl;
  227|     32|        } else if (isTrapezoid(slopeAB, slopeBC, slopeCD, slopeDA)){
  228|      0|            std::cout << "trapezoid" << std::endl;
  229|     32|        } else if (isKite(distanceAB, distanceBC, distanceCD, distanceDA)){
  230|      0|            std::cout << "kite" << std::endl;
  231|     32|        } else std::cout << "quadrilateral" << std::endl;
  232|     32|    }
  233|     32|    //    std::cout << "BLANK LINE" << std::endl;
  234|     32|}
  235|       |
  236|    100|int main(int argc, const char * argv[]) {
  237|    100|    vector<int> vertices;
  238|    100|    string line;
  239|    200|    while(getline(cin, line)){
  240|    100|        if(error1(line)){
  241|      0|            exitError("error 1");
  242|      0|//            continue;
  243|      0|        }
  244|    100|        vertices = parseToVector(line);
  245|    100|        if(error1(vertices)){
  246|      0|            exitError("error 1");
  247|      0|//            continue;
  248|      0|        }
  249|    100|        if(error2(vertices)){
  250|      0|            exitError("error 2");
  251|      0|//            continue;
  252|      0|        }
  253|    100|        if(error3(vertices)){
  254|     68|            exitError("error 3");
  255|     68|//            continue;
  256|     68|        }
  257|    100|        if(error4(vertices)){
  258|      0|            exitError("error 4");
  259|      0|//            continue;
  260|      0|        }
  261|    100|        printQuadrilateralType(vertices);
  262|    100|    }
  263|    100|}

